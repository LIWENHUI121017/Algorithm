# 汉明距离

[查看代码](https://github.com/LIWENHUI121017/Algorithm/blob/master/low/mathematics/romanToInt/main.go)

两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。

给出两个整数 x 和 y，计算它们之间的汉明距离。

注意：
0 ≤ x, y < 2^31.

示例:

```go
输入: x = 1, y = 4

输出: 2

解释:
1   (0 0 0 1)
4   (0 1 0 0)
          ↑    ↑

上面的箭头指出了对应二进制位不同的位置。
```

###  方法一：

将两个二进制数同时与（&）1，如果结果不相等，则计数 + 1

##### 复杂度分析

- 时间复杂度：O(1) 。同时扫描，最差的话就x或者y是一个 32 位数，要循环32次，所以运行时间是 O(1) 的。
- 空间复杂度：O(1)。使用恒定大小的空间保存计数的结果。

```go
func hammingDistance(x int, y int) int {	
	count := 0
	//两个int每一位都和1与运算，如果结果不相等，计数加一
	for x != y  {
		if x&1 != y&1 {
			count++
		}
		//然后往右移
		x >>= 1
		y >>= 1
	}
    return count    
}
```



### 方法二：

利用异或的特性，1^1=0 ，1^0=1，例如1和4对比，他们的的二进制是：001 和 100，异或之后变成：011，1的数量有2位，也就代表了两个数字的二进制不相同的位置总共有两个，所以接下来我们只需要计算两个数异或后的数的二进制中，1的数量就是答案了。

##### 复杂度分析

- 时间复杂度：O(1) 。同时扫描，最差的话就x或者y是一个 32 位数，要循环32次，所以运行时间是 O(1) 的。
- 空间复杂度：O(1)。使用恒定大小的空间保存计数的结果。

```go
func hammingDistance(x int, y int) int {	
    count := 0
	num := x^y
	for num != 0 {
		if num&1 == 1 {
			count++
		}
		num >>= 1
	}
    return count    
}
```

### 方法三：

计数这个异或的时候可以用之前求位1的个数里面的方法，直接用n&(n-1)，就能把最右边1去掉，每一次循环都去掉一个最右边的1，当所有的1都去掉了，n就会变成0，n&(n-1)运算的次数就是异或后的二进制里面1的数量。

##### 复杂度分析

- 时间复杂度：O(1) 。与移位方法相似，由于整数的位数恒定，因此具有恒定的时间复杂度，但是该方法需要的迭代操作更少，迭代次数只看异或后的二进制数里面1有多少个。
- 空间复杂度：O(1) 。没有使用额外空间。

```go
func hammingDistance(x int, y int) int {	
    count:=0
	num := x^y
	for num!=0{
		count++
		num = num&(num-1)
	}
	return count
}
```